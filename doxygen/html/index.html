<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mem-FG: MemFG</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mem-FG
   &#160;<span id="projectnumber">1.00.00</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">MemFG </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>MemFG</b> is a module written in Python, which allows us to</p>
<ul>
<li>define user-custom models of dwarf spheroidal galaxies (dSphs),</li>
<li>evaluate, test, and compare dSph models,</li>
<li>search the parameter region of a given dSph,</li>
<li>estimate J-factor PDFs or confidencial intervals.</li>
</ul>
<p><b>MemFG</b> module is implemented to satisfy that</p>
<ul>
<li>dSph models can be defined by using a specific model format in MemFG,</li>
<li>all of the output files yielded by MemFG have a user-friendly and easily-reuseable format,</li>
<li>statistical frameworks can be swicthed between such as frequentist statistics or Bayesian statistics.</li>
<li>sampling algorithm can be switched among several MCMC or nested samplers.</li>
</ul>
<h1>Todo</h1>
<h2><code>Parameter</code> class?</h2>
<ul>
<li>Usually, a likelihood function has many parameters (more than 10). Let us consider that we pass these parameters to the likelihood as:</li>
</ul>
<div class="fragment"><div class="line">likelihood(p0,p1,p2,p3,p4,p5,...)</div></div><!-- fragment --><p>This may cause some bugs such that</p>
<div class="fragment"><div class="line">likelihood(p0,!p2,!p3,!p1,p4,...)</div></div><!-- fragment --><p>Of cource, we can avoid such bugs by taking very careful to the order of the arguments. However, if we can just call the likelihood as:</p>
<div class="fragment"><div class="line">likelihood(ps)</div></div><!-- fragment --><p>this helps us to coding very quickly. In order to achieve this feature, we should define a format of the order of the arguments <code>ps</code>. We should take care that the <code>emcee.EnsembleSampler</code> is defined as:</p>
<blockquote class="doxtable">
<p><code>emcee.EnsembleSampler(nwalkers, dim, lnpostfn, a=2.0, args=[], kwargs={},...)</code> </p>
</blockquote>
<p>where</p>
<blockquote class="doxtable">
<p><code>lnpostfn</code>: A function that takes a <b>vector</b> (<b>numpy.array</b>) in the parameter space as input and returns the natural logarithm of the posterior probability for that position. </p>
</blockquote>
<p>Moreover, we should also take care that the computational cost of the likelihood function should be small.</p>
<p>一番実装が簡単なのは、Arrayをそのまま使ってしまうこと。例えばLikelihoodの中で、 p0,p1,p2, ... = ps とか展開して、それぞれのpiはこういう意味だから...とか考えながら、適宜Likelihoodの中で使う。 しかしこれは非常に危ない（取り違えが起きる可能性ありまくる）。 順番がめちゃめちゃにならないようにどっかでパラメータの順番を明示的に指定してあげて、 「この変数はこのパラメータ、この変数はこのパラメータ」と教えてあげたいのだが、 それをやると結局そこに問題を押し付けただけになる（そこで間違えたらどうする？）。 例えば間違えないように、 velocity = p["velocity"], position = p["position"], みたいな代入をしてもいいけれど、これだとなんか関数を定義するたびに頭で毎回こういうことをしないといけなくなる。 これはいちいち時間を食うし（dict型ならそんなでもない）、冗長である（これはそう）。 かといって、関数の引数にデデンと全部書いてしまうと、それこそ20個近い変数を全部書くことになって、可視性が悪い。</p>
<p>Likelihood、というか継承・複合しまくったモデルのパラメータが肥大する理由は、各々のモデルの持っているパラメータが全部一つにまとまってしまうから。 しかし実際はパラメータは各々のモデルにBoundされた概念である。なので、それごとに分けてしまえばそれほど数は大きくならない（はず）。</p>
<p>つまり、psをモデルごとに分けたいので、 ps_stellar,ps_dm = self.split_params(ps,[stellar_model,dm_model]) みたいなことをしたい。これならそんなに冗長でもない。 問題は最下層のモデルでどう展開するか。 これは、 a,b,g = self.split_params(p0,["a","b","z"]) みたいにすれば良いかな？ほんとに？ これってなんか辞書でアクセスしてるのと似てるから、 a,b,g = self.params(["a","b","h"]) みたくすればよいか。 いやでも、なんか自分でモデルを定義したくなった時にこういう記法を強制させるのはキモい。 一番最下層のモデルでは、単に何かの関数は単純に def func(a,b,g): ... return ret みたく書きたい。しかしこれだと関数の順番がここで決まってしまう... 一般にモデルにはパラメータが合って、順番が定義されている。その順番で使うように強制したいのだけど。。。 やはり、最下層のモデルでも a,b,g = self.split_params(p0,["a","b","z"]) みたいな書き方をさせよう。あるいは、デコレータを定義して、ナマの形の関数を変更しよう。</p>
<p>バグが起きそうな原因というのは、手でパラメータの順番を陽に・陰に 指定してしまうこと。これをなくすには、辞書でパラメータを指定するようにすればいい。 ただし、Likelihoodの評価の時にだけは順序が関係してくる。 そのため、Likelihoodの引数の順序は特定の規則に従って勝手に決まるようにして、順番が現れないようにすればよい。</p>
<p>あれ、ていうか、よく考えるとパラメータに値をAssignする必要はないような？？ なぜなら、なんかモデルを評価するときにモデルにパラメータをassignしているわけではない...</p>
<p>なにかモデルを評価するときには、パラメータ空間上の特定の点に対してLikelihoodの値を評価する、ということをやる。その意味では、パラメータはむしろ一般のclassとして定義すべきであるきがする。その意味だと、Modelはパラメータ空間を持ち、パラメータ空間の特定の一点でモデルを評価する、ということになる。クラスがクラスを持つ、とはどういうことか？？？</p>
<p>今まで考えていたのはむしろ「パラメータはspecified/unspecifiedという属性を持つ」ということ。こっちのがわかりやすい気がする。 で、モデルの評価について考えると、 モデルはパラメータを持つ。 モデルは、SpecifiedなParameterを持っているとき、Likelihoodの評価ができる。 モデルがSpecifiedされているとは、モデルのパラメータがすべてSpecifiedされてることである。 モデルは、複モデルを持つ。 モデルがSpecifiedされているとき、複モデルもすべてSpecifiedである。 モデルがSpecifiedされているとは、モデルパラメータが値を持つことである。 モデルが値を持つとき、複モデルも値を持つ。 モデルを評価するとは、 Specifiedなパラメータの値に基づき、Likelihood(values)を求めること。 Specifiedされていないときは、エラーになる。</p>
<p>あるいは、関数の評価をするときには必ず値をassignするようにして、関数内部ではself.parameter["name_of_parmaeter"]という風に呼ぶようにするのでいいかもしれない。 これだと、どの関数がどの変数に依存しているのかわかりづらいという欠点があるが…</p>
<p>変数を明示するには、変数を引数に書いとくのが良い。 そこで、 func_test(x,a,b,c) みたいな関数を定義したとき、自動で test(x,p) みたいな関数を再定義してくれるようにしたい。 param_names = ["a","b"]</p>
<p>def func_test(x,b,a): これならわざわざ最初に変数を自分で定義しなおす必要はない。 この関数は上のレイヤーのモデルから簡単に呼び出せる。</p>
<p>。。。いや、待てよ？関数の引数は必ずしも全部のパラメータを尽くすわけではないから、 都合よく変数を抽出する必要がある。これはちょっとめんどくさい… …やっぱり、最初にモデルの変数をAssignするようにしてしまおう。</p>
<p>...しかしこれも問題がある。最初にモデルのパラメータ全部をAssignしてしまうと、 下のモデルの関数を呼び出すときに再度Assignが発生する気がする…</p>
<p>これは使う関数を分ければよい。モデルの定義に使う関数と、実際の評価に使う関数を分ける: </p><pre class="fragment">定義に使う関数　`func_f`:
    ```python:
    def func_f(self,x,a,b,Parameter_Model1,Parameter_Model2):
        ...
        self.Model1.func_f1(x,*Paramster_Model1)
    ...

呼び出し方　f(x):この時、パラメータは事前にAssignされる。
</pre><p>…これもなんか問題があるな… 例えばLikelihoodとかは（例えばというかこれが主目的なのだが） likelihood(*p) ないし likelhood(p) とかいう形で呼び出す（ようなものを定義しないとMCMCで使えない）。 ここでpはFlatな配列になっている。 このLikelihoodの定義中で呼び出すモデルの関数は、pを引数にとらないといけない。 （あるいは、Likelihoodの評価前に事前にAssignを行っておく。） 定義を書くときには、モデルの関数のP依存性は…書きたい？？ よく考えると、一個下のモデルの関数を何かしらで呼び出すことはある。 たとえば、Likelihoodはdsphのモデルの関数sigmalosを呼び出すので、 こいつにはどうにかしてpの情報のうちdsphモデルに相当する分をあげないといけない。</p>
<p>方針としては、パラメータを引数に持つような関数は事前にモデルにAssignをしてから使うようにする、というのがあげられるが、これだとモデルを上に登って行ったとき二重Assignの問題が常にある。</p>
<p>ちゃんと考えるために、良さげな候補となる関数の書き方をいくつかにグループ分けする：</p>
<ol type="1">
<li>func_raw(x,y,a,b,Parameter_Model1,Parameter_Model2)</li>
</ol>
<ol type="1">
<li>func_flat(x,p)</li>
</ol>
<ol type="1">
<li>func_using_assigned_parameter(x)</li>
</ol>
<p>それぞれ、内部をどういう風に記述したらいいか考えてみると、</p>
<p>``` def func_raw(self,x,y,a,b,Parameter_Model1,Parameter_Model2): (... some calculation with a,b... ) func_Model1_flat(x,Parameter_Model1) ```</p>
<p>``` def func_flat(self,x,p): # likelihoodはどうにかしてこの形式のものを用意する必要がある a,b,Parameter_Model1,Parameter_Model2 = self.split_param(p) (... some calculation with a,b... ) func_Model1_flat(x,Parameter_Model1)</p>
<h1>Usage:</h1>
<p>func_flat(x,p) ```</p>
<p>``` def func_using_assigned_parameter(x): a,b = self.parameter[["a","b"]] # あるいは直接これを式中で呼び出す func_Model1_using_assigned_parameter(x) # assignされている値を使う func_Model2_flat(y,self.parameter["Parameter_Model2"])　# 代入をする</p>
<h1>Usage:</h1>
<p>(some assignment procedure before calling) func_using_assigned_parameter(x) ```</p>
<p>それぞれメリット・デメリットがある。</p>
<ol type="1">
<li><ul>
<li>! 変数が明確。</li>
<li>? Likelihoodの形とずれてるので、少しだけ変更が必要。</li>
<li>? 上下のモデル全部含めて全部raw形式ではかけない（内部でflat形式を呼んでいるので）</li>
</ul>
</li>
</ol>
<ol type="1">
<li><ul>
<li>! Likelihoodの形とあっているので、そのまま使える。</li>
<li>? 内部でパラメータの展開が必要。</li>
</ul>
</li>
</ol>
<ol type="1">
<li><ul>
<li>! いちいち内部で下のモデルのパラメータを気にする必要がない。</li>
<li>? 実行前に事前にAssignが必要。</li>
<li>? 関数が何に依存してるのかがパット見でいまいちわかりにくい。<ul>
<li>てかこれって結局最初に自分のパラメータだけは展開がいるんじゃね？</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>それぞれの関数はwrapperを作ることで行き来ができるから、 一番**表記上**望ましいものを採用するべき。</p>
<p>表記上望ましいのはraw形式なので、これを採用することにする。 rawからflatへの行き来は、ラッパを作ることにする。</p>
<p>func_と定義された関数は、自動的にflat形式の関数に展開することにする。 どうするか…</p>
<p>flat な変数を受けてrawの変数に展開するには、 一旦モデルのパラメータとしてAsssignしているとこだけ取り出すか、 ダイレクトに配列をそのまま分けるやり方がある。</p>
<p>モデルのパラメータとしてAssignするのは…？ もし何かモデルがパラメータの実現値を持っているなら合理的な気がするけど、 まだ値がわからん段階で何か値をAssignするというのは違う気がする。</p>
<p>モデルのパラメータじゃなくてAssignするのはよさそう。 つまり一時的にパラメータのインスタンスを作成して、 そこに値をAssignし、そこから値を読み出す。 …めんどくせえなこれ…これってしかもわざわざインスタンスを生成しているので遅そう。 （一方で実際にモデルが何かの値を持っているということもありそうだから、 これはこれとして別に実装するのがよさそう。）</p>
<p>一方、ダイレクトに分けるのは簡単で、既に実装済みである。 （Assignのやり方と比較して気になるのは、パラメータを分割するときのコスト。 そんなでもないか？？？→そんなでもなさそう。） 単にLikelihoodを評価するだけなら、これでよい。</p>
<p>クラスメソッドとして定義するのが良いであろう。 なぜなら別に特定のインスタンスによっているわけではないから。 ただしStaticmethodだとおかしなことになる（submodelによるので）。 -&gt; これ変じゃない？？？モデルそれ自体はSubmodelの型を保持しているが、 インスタンス化されたモデルはSubmodelとしてモデルのインスタンスを含んでいる。 モデルの関数は子モデルの持つメソッドを呼び出すことがあるが、 この時呼び出すのは子モデルの持つ…メソッドないしクラスメソッド。</p>
<p>サブモデルをもつモデルについて、インスタンス化される前にクラスメソッドが評価できるようにすべきか、しないべきか？ …モデルにも二種類ある：</p><ul>
<li>具象モデル: すべてのメソッドが実装済みのモデル</li>
<li>抽象モデル: テンプレートとして定義され、継承先で実装が与えられるべきモデル 一方で、継承関係とは別に包含関係もあるので、Submodelとしては具象モデル、抽象モデルのどちらも取りうる。 仮にSubModelとして抽象モデルを取ってきた場合、 どっかで実装を与えてあげないとSubmodel依存の親モデル関数の評価ができない。 これはどのようにして与えるべきか…</li>
</ul>
<p>やはり、物理的な関数はインスタンスメソッドとして定義して、 インスタンス化しないと使えないようにしよう。 実際、抽象モデル（テンプレート）は実装を持たずインスタンス化できないので、 物理的な関数を呼び出すことはできない。</p>
<p>一方で、モデルはパラメータを持っているのだった。 モデルの継承をした時にパラメータがどうなるかを考えていなかったが… 問題がある： 抽象モデルAbstractSubModelをSubmodelに持つモデルModelを定義し、コンストラクタで 具象モデルConcreteSubModelのインスタンスを与えることでモデルを作るとする。 しかし、具象モデルのインスタンスを与えてもModelの関数の引数はAbstractSubModel_Parameterで書かれているので、 引数チェックをする時に弾かれてしまう… これを解消するには、ConcreteSubModelのパラメータをAbstractSubModelのパラメータとして変換してあげるようにしたい… 要は引数チェックに問題があるので、まずはそこをWrapして別メソッドにしよう。 どういうメソッドになるといいかというと… なにか数を受けて、</p>
<p>モデルそれ自体も、何かしらパラメータを持っている。 ええと… 抽象モデルが持ってなきゃいけないパラメータというものがある。 （しかし、Half-light-radiusだったりRexpだったりするからややこしい） 一方で、必ずしも持っている必要はないが、必要に応じて具象モデルで追加されるべき パラメータというのも存在する...</p>
<p>モデルをインスタンス化すると、パラメータのインスタンスが生成される。 モデルの関数は、そのパラメータに基づき評価されるようになり、 パラメータをFlattenした関数もインスタンス化と同時に定義される。</p>
<p>どの関数を直して、どの関数を直さないかはどうやって判別するか。 デコレータを使ってしまうのが良いだろう。</p>
<p>```python:  func(cls,x,a,b,c): pass ```</p>
<p>とかやると、勝手にこの関数を変換し、クラスメソッドとして登録する用にしたい。 問題なのは、変更した後の名前。func -&gt; func_flatten でいいか。 …いいか？冗長でない？ むしろ変更する前の関数を何か別の名前にするか…どっちがいいかな… 呼ばれ方を上のリストを元に考えると、 元の関数を <code>_func</code> としてしまい、新しい関数を<code>func</code>にするのが良さそう。</p>
<p>そのためには…</p>
<p>デコレータめんどくさそうなので、従来の方式で行く（astropyもこういう理由なのか？）。</p>
<p>やりたいことは、</p>
<ul>
<li>クラスから呼び出されたら、与えられた値を使って評価する。</li>
</ul>
<pre class="fragment"> デコレータにするためには、どうしてもパラメータの情報がいる。頭に渡すことにしてもいいが：

 ```python
 @deco(parameter)
 ```

 冗長でない？？？
 そうでもないか。これでどのパラメータがpackされるかがわかりやすくなるかな？
 自分以外のパラメータをPackしてしまう危険もあるが…まあ大丈夫だろう。
 後は、継承とかしたときに大丈夫か…
 継承してパラメータを増やしたりされた時、デコレータがおかしくならないか？
 ともかくやってみる。


 自作デコレータでデコレートしてあげて、それだけ選んで変換を行うようにした（Classmethodであることを忘れがちなので）。
 ここで、問題に気づいた：

 AbstractModel的なものを定義した時、継承をしても関数の変換がAbstractModelの方だけでしか行われない。
 これだと、AbstractModel側でパラメータの定義を特にしないと、AbstractModelで定義したPhysClassMethodが
 無のパラメータを引数に取ることになり、それがそのままConcreteModelに引き継がれてしまう。
 また、AbstractModelのSubModelたちは得てしてAbstractModelな場合もあるが、
 その場合モデルのパラメータはそのAbstractModelの名前をそのまま引きつぐ。
 しかし継承先で実装が与えられるのだとしたら、継承先では継承先のモデルの名前になっていてほしい。

 なので、クラスの継承をした場合は、
 継承先のモデルのパラメータを継承先のparam_names,sub_modelsを用いて更新し、
 (これは既にできている。なぜなら__new__はModelの定義時に必ず呼ばれるから。)
 継承先のモデルのパラメータで再びFlat化をし直してあげたい。
 （これはできていない。クラスの継承をした場合、子クラスから親クラスのメソッドを
 呼ぼうとすると、クラスツリー（継承関係のツリー？）を辿って親クラスのメソッドが呼ばれる。
 しかしこの親クラスのメソッドは親クラスのparameterを使ってFlattenされているので、そのまま呼び出したくはない。
 子クラスに同名のメソッドがあれば、そちらが呼ばれるので、同名のメソッドを定義し直すようにする。）

 ふたとおりやり方がある気がする：

 1. ModelMetaでやっちゃう方法。
 2. __init_subslass__ を使う方法。

 どちらもほぼ同じことができるが…違いは、MetaClassに書いておけば他のクラスでも使える、ということ。
 しかし今の場合はModelMetaはModel定義にしか使っていないので、どっちを使おうが大差ない。
 今回は、Modelの定義時のあれこれはMetaClassに担当してもらうことにして、
 Model自体ではインスタンス生成について記述する、というふうに分けることにする。

 これだと、BaseClassで定義した関数で新しい関数を上書きしてしまうな…
 -&gt; 先にやればいいのか。

 まてよ、ややこしい問題がある：
 AbstractDSphModelを、StellarModel,DMModelを要素に持つように作る。
 これを継承して、ConcreteDSphModelを作るとする。
 この時、AbstractDSphModelでもしPhysClassMethodを実装すると、
 継承先のConcreteDSphModelで引数の形が合わなくなる
 （継承前はParameter_StellarModelとかを引数に持ち、
 継承後はParameter_PlummerModelとかを引数に持つように
 Flatteningされるが、これらは違うパラメータなので…目的とする変数に何も代入されなくなる？）

 いろいろごっちゃになってきているので整理すると、
 Modelそれ自体は受容できるsub_modelインスタンスの型
 sub_model_cls_dictを持っている。
 よくよく考えると、モデルは複数の同じ型のsubmodelを持つことがありうる
 （例えば複数コンポーネントを持つPlummerModelの場合）。
 その意味で、モデルを生成する時に単にリストとして渡してしまうと、
 モデルがごっちゃになる可能性がある。
 これを避けるため、辞書型にしておく必要がある。
</pre><p>Hence, in order to achieve this feature, we separate the definition of likelihood from the implementation of likelihood. In a definition step,</p>
<div class="fragment"><div class="line">def likelihood(Parameters params):</div><div class="line">    (some computation)</div><div class="line">    return ret</div></div><!-- fragment --><p>Then, Model class understand this likelihood function as</p>
<div class="fragment"><div class="line">def likelihood(np.array ps)</div><div class="line">    ...</div></div><!-- fragment --><p>Is is possible???</p>
<h2>Implementation</h2>
<p>To achieve the demands mentioned above, MemFG has the following classes:</p>
<ul>
<li>class <code>Model</code>: define all physical or statistical models in MemFG.<ul>
<li><code>Model</code> has <code>parameters</code>.<ul>
<li><code>parameters</code> is a <code>list</code> of <code>Parameter</code>s.</li>
</ul>
</li>
<li><code>Model</code> has <code>submodels</code>.<ul>
<li><code>submodels</code> is a <code>list</code> of <code>Model</code>s.</li>
</ul>
</li>
<li><code>Model</code> has <code>param_names</code>.<ul>
<li><code>param_names</code> is a list of parameter.name for parameter in parameters.</li>
</ul>
</li>
<li><code>Model</code> has <code>all_parameters</code>. <code>all_parameters</code> is a list of <code>Parameter</code>s which a <code>Model</code> of submodels` has.</li>
<li><code>Model</code> has some <code>function</code>s.<ul>
<li><code>function</code> has a <code>body</code>.</li>
<li><code>function</code> has a <code>args</code>.<ul>
<li><code>args</code> is some <code>names</code> of <code>parameters</code>.</li>
</ul>
</li>
<li><code>function</code> can <code>check_args</code>: <code>check_args(params)</code>:<ul>
<li>params: a instance of <code>Parameters</code></li>
</ul>
</li>
<li><code>function</code> can <code>__call__</code>: <code>__call__(params)</code>:<ul>
<li>params: a instance of <code>Parameters</code><ul>
<li>during the calculation, parameters of Model</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Model</code> can <code>split_params</code>: <code>split_params(params)</code></li>
</ul>
</li>
<li><p class="startli">* class <code>Parameters</code>: ??? (Is it actually required?)</p><ul>
<li><code>Parameters</code> is a <code>list</code>.　??? (or has a <code>list</code> or <code>dict</code> of <code>Parameters</code>???)</li>
<li><code>Parameters</code> has a <code>names</code>.</li>
<li><code>Parameters</code> has a <code>values</code>.</li>
<li><code>Parameters</code> can <code>assign_values</code>.</li>
<li><code>Parameters</code> can <code>clear_values</code>.</li>
</ul>
<p class="startli">&ndash;&gt; a set of parameters is also parameter !!!</p>
</li>
<li>class <code>Parameter</code>:<ul>
<li><code>Parameter</code> has <code>name</code>.<ul>
<li><code>name</code> is a <code>string</code> or a <code>list</code> of <code>string</code></li>
</ul>
</li>
<li>* <code>Parameter</code> has <code>unit</code>.<ul>
<li><code>unit</code> is a <code>string</code> or a <code>list</code> of <code>string</code></li>
</ul>
</li>
<li><code>Parameter</code> has <code>value</code>.<ul>
<li><code>value</code> is a <code>double</code> or a <code>list</code> of <code>double</code></li>
</ul>
</li>
<li><code>Parameter</code> has <code>sub_params</code>.<ul>
<li><code>sub_params</code> is a list of <code>Parameter</code>s.</li>
</ul>
</li>
<li><code>Parameter</code> can <code>clear_value</code>.</li>
<li><code>Parameter</code> can <code>assign_value</code>.</li>
<li>* <code>Parameter</code> can <code>convert_unit</code>.</li>
<li><code>Parameter</code> has <code>belonged_model</code>.</li>
<li><code>Parameter</code> has <code>dim</code>.</li>
<li><code>Parameter</code> can <code>__len__</code><code> -</code>Parameter<code>can</code>__or__<code>or</code>|<code>. -</code>Parameter<code>can</code>add<code>other parameters into</code>self.sub_params`.</li>
</ul>
</li>
<li>class <code>DMModel</code>: define dark matter density profile.<ul>
<li><code>DMModel</code> is a <code>Model</code>.</li>
<li><code>DMModel</code> has <code>enclosure_mass</code>.</li>
<li><code>DMModel</code> has <code>density_profile</code>.</li>
</ul>
</li>
<li>class <code>StellarModel</code>: define stellar models of dSPhs.<ul>
<li><code>StellarModel</code> is a <code>Model</code>.</li>
<li><code>StellarModel</code> has</li>
</ul>
</li>
<li>class <code>PlummerModel</code>: define the Plummer model.<ul>
<li><code>PlummerModel</code> has a <code>list</code> of <code>Parameter</code>: <code>r_half</code></li>
</ul>
</li>
<li>class <code>dSphModel</code>: define dSph models.<ul>
<li><code>dSphModel</code> is a <code>Model</code>.</li>
<li><code>dSphModel</code> has <code>stellar_model</code> and <code>dm_model</code>.<ul>
<li><code>stellar_model</code> is a <code>StellarModel</code>.</li>
<li><code>dm_model</code> is a <code>DMModel</code>.</li>
</ul>
</li>
<li><code>Model</code> can <code>fit</code> <code>ObservedData</code>,</li>
<li><code>Model</code> can <code>evaluate_loglikelihood</code> based on <code>ObservedData</code>,</li>
</ul>
</li>
<li>``</li>
<li></li>
<li></li>
</ul>
<h1>Note</h1>
<p>Some usual frameworks:</p>
<ul>
<li>A <code>Dog</code> has a <code>tail</code>.<ul>
<li>An instance of <code>Dog</code> class has an attribute <code>tail</code></li>
</ul>
</li>
<li>The <code>Dog</code> has a <code>binomen</code>.<ul>
<li>The <code>Dog</code> class has an attribute <code>binomen</code>.</li>
</ul>
</li>
<li>A <code>Dog</code> is an <code>Animal</code>.<ul>
<li>An instance of the <code>Dog</code> class is also an instance of the <code>Animal</code> class. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
